#!/usr/bin/env python -tt
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

DOCUMENTATION = '''
---
module: vagrant
short_description: create a local instance via vagrant
description:
     - creates VM instances via vagrant and optionally waits for it to be 'running'. This module has a dependency on python-vagrant.
version_added: "100.0"
options:
  state:
    description: Should the VMs be "present" or "absent."
  cmd:
    description:
      - vagrant subcommand to execute. Can be "up," "status," "config," "ssh," "halt," "destroy" or "clear." 
    required: false
    default: null
    aliases: ['command'] 
  box_name:
    description:
      - vagrant boxed image to start
    required: false
    default: null
    aliases: ['image']
  box_path:
    description:
      - path to vagrant boxed image to start
    required: false
    default: null
    aliases: []
  vm_name:
    description:
      - name to give an associated VM
    required: false
    default: null
    aliases: [] 
  count:
    description:
      - number of instances to launch
    required: False
    default: 1
    aliases: []
  forward_ports:
    description:
      - comma separated list of ports to forward to the host
    required: False
    aliases: []    
  
examples:
   - code: 'local_action: vagrant cmd=up box_name=lucid32 vm_name=webserver'
     description: 
requirements: [ "vagrant" ]
author: Rob Parrott
'''

VAGRANT_FILE = "./Vagrantfile"
VAGRANT_DICT_FILE = "./Vagrantfile.json"
VAGRANT_LOCKFILE = "./.vagrant-lock"

VAGRANT_FILE_HEAD = "Vagrant.configure(\"2\") do |config|\n"
VAGRANT_FILE_BOX_NAME = "  config.vm.box = \"%s\"\n"
VAGRANT_FILE_HOSTNAME_LINE     = "  config.vm.hostname = \"%s\"\n"
VAGRANT_FILE_PORT_FORWARD_LINE = "  config.vm.network :forwarded_port, guest: %s, host: %s\n"
VAGRANT_NETWORK_LINE = "  config.vm.network :%s"
VAGRANT_NETWORK_BRIDGED_FRAGMENT = ", :bridge => \"wlan0\", :ip => \"%s\" "
VAGRANT_NETWORK_HOSTONLY_FRAGMENT = ", virtualbox__intnet: true"
VAGRANT_NETWORK_LINE_END = "\n"
VAGRANT_VBOX_LINE = """
  config.vm.provider "virtualbox" do |vbox|
      vbox.name = "%s"
  end
"""

VAGRANT_FILE_TAIL = "\nend\n"

DEFAULT_VM_NAME = "ansible"

import sys
import subprocess
import os
import os.path
import json

try:
    import lockfile
except ImportError:
    print "Python module lockfile is not installed. Falling back to using flock(), which will fail on Windows."
    
try:
    import vagrant
except ImportError:
    print "failed=True msg='python-vagrant required for this module'"
    sys.exit(1)

class VagrantWrapper(object):

    def __init__(self, destDir, vmname):

        '''
        Wrapper around the python-vagrant module for use with ansible.
        '''
        self.destDir = os.path.join(destDir, vmname)
        if not os.path.isdir(self.destDir):
            os.makedirs(self.destDir)

        # Initialize vagrant and state files
        self.vg = vagrant.Vagrant(self.destDir)

    def prepare_box(self, box_name, box_path):
        """
        Given a specified name and URL, import a Vagrant "box" for use.
        """
        changed = False
        if box_name == None:
            raise Exception("You must specify a box_name with a box_path for vagrant.")
        boxes = self.vg.box_list()
        if not box_name in boxes:
            self.vg.box_add(box_name, box_path)
            changed = True

        return changed

    def up(self, box_name, vm_name=None, box_path=None, ports=[], network_type=None, ipaddr=None):
        """
        Fire up a given VM and name it, using vagrant's multi-VM mode.
        """
        changed = False
        if vm_name == None: 
            vm_name = DEFAULT_VM_NAME

        if box_name == None:
            raise Exception("You must specify a box name for Vagrant.")
        if box_path != None: 
            changed = self.prepare_box(box_name, box_path)
        
        vm_params = {}
        vm_params['vm_name'] = vm_name
        vm_params['box_name'] = box_name
        vm_params['forwarded_ports'] = ports
        vm_params['network_type'] = network_type
        vm_params['ipaddr'] = ipaddr

        self._get_or_create_instance(vm_params) 
        if not vm_params.has_key('box_name'): 
            vm_params['box_name'] = box_name

        vm_params['forward_ports'] = ports
        vm_params['network_type'] = network_type

        # See if we need to fire it up ...
        status = self.vg.status()
        if status['default'] != 'running':
            self.vg.up(False)
            changed =True

        ad = self._build_instance_array_for_ansible(vm_params)
        return (changed, ad)

    def status(self):
        """
        Return the run status of the VM instance. 
        """
        status = self.vg.status()
        return (False, status['default'])

    def config(self):
        """
        Return info on SSH for the running instance.
        """
        return (False, self.vg.conf(None))

    def halt(self):
        """
        Shuts down a vm_name or all VMs.
        """
        changed = False
        (ignore, status) = self.status()
        if status == 'running':
            self.vg.halt()
            changed = True

        return (changed, status)

    def destroy(self):
        """
        Halt and remove data for a VM, or all VMs.
        """
        (changed, stats) = self.halt()

        self.vg.destroy()
        changed = True

        return changed

    def clear(self):
        """
        Halt and remove data for a VM, or all VMs. Also clear all state data
        """
        changed = self.vg.destroy()
        return changed

#
# Helper Methods
#
    def _get_or_create_instance(self, vm_params):
        vagrant_file = os.path.join(self.destDir, 'Vagrantfile')

        vagrant_data = {}
        if not os.path.exists(vagrant_file):
            # Create new Vagrantfile
            self._write_vagrantfile(vagrant_file, vm_params)

    def _write_vagrantfile(self, file, vm_params):
        vfile = open(file, 'w')
        vfile.write(VAGRANT_FILE_HEAD)

        vfile.write(VAGRANT_FILE_BOX_NAME % (vm_params['box_name'],))
        vfile.write(VAGRANT_FILE_HOSTNAME_LINE % (vm_params['vm_name'],))
        if vm_params['network_type'] != 'nat':
            vfile.write(VAGRANT_NETWORK_LINE % (vm_params['network_type'],))

            if vm_params['network_type'] == 'public_network':
                vfile.write(VAGRANT_NETWORK_BRIDGED_FRAGMENT % (vm_params['ipaddr'],))
            elif vm_params['network_type'] == 'private_network':
                vfile.write(VAGRANT_NETWORK_HOSTONLY_FRAGMENT)

            vfile.write(VAGRANT_NETWORK_LINE_END)

        vfile.write(VAGRANT_VBOX_LINE % (vm_params['vm_name'],))

        if vm_params.has_key('forward_ports'):
            for p in vm_params['forward_ports']:
                vfile.write(VAGRANT_FILE_PORT_FORWARD_LINE % (name,p,p) )

        vfile.write(VAGRANT_FILE_TAIL)
        vfile.close()

    #
    # To be returned to ansible with info about instances
    #
    def _build_instance_array_for_ansible(self, vm_params):
        vm_name = vm_params['vm_name']
 
        ans_instances = []
        cnf = self.vg.conf(None) 
        if cnf != None:
            status = self.vg.status()
            d = {
                'id': cnf['Host'],
                'public_ip': cnf['HostName'],
                'public_dns_name': cnf['HostName'],
                'port' : cnf['Port'],
                'username' : cnf['User'],
                'key' : cnf['IdentityFile'],
                'status' : status['default']
                }
            d.update(vm_params)
            ans_instances.append(d)

        return ans_instances

#--------
# MAIN
#--------
def main():

    module = AnsibleModule(
        argument_spec = dict(
            dest=dict(required=True),
            state=dict(),
            cmd=dict(required=False, aliases = ['command']),
            box_name=dict(required=False, aliases = ['image']),
            box_path=dict(),
            vm_name=dict(require=True),
            forward_ports=dict(),
            network_type=dict(default='nat'),
            ipaddr=dict(default='192.168.2.')
       )
   )

    dest    = os.path.abspath(os.path.expanduser(module.params['dest']))
    state = module.params.get('state')
    cmd = module.params.get('cmd')
    box_name = module.params.get('box_name')
    box_path = module.params.get('box_path')
    vm_name = module.params.get('vm_name')
    forward_ports = module.params.get('forward_ports')     
    network_type = module.params.get('network_type')
    ipaddr = module.params.get('ipaddr')

    if network_type == 'bridged':
        network_type = 'public_network'
    elif network_type == 'hostonly':
        network_type = 'private_network'

    if forward_ports != None:
        forward_ports=forward_ports.split(',')
    if forward_ports == None: forward_ports=[]

    # Initialize vagrant
    vgw = VagrantWrapper(dest, vm_name)

    #
    # Check if we are being invoked under an idempotency idiom of "state=present" or "state=absent"
    #
    try:
        if state != None:

            if state != 'present' and state != 'absent':
                module.fail_json(msg = "State must be \"present\" or \"absent\" in vagrant module.")

            if state == 'present':

                changd, insts = vgw.up(box_name, vm_name, box_path, forward_ports, network_type, ipaddr)
                module.exit_json(changed = changd, instances = insts)

            if state == 'absent':
                (changed, status) = vgw.halt()    
                module.exit_json(changed = changed, status = status)

        #
        # Main command tree for old style invocation
        #

        else:

            if cmd == 'up':
                (changd, insts) = vgw.up(box_name, vm_name, box_path, forward_ports, network_type, ipaddr)
                module.exit_json(changed = changd, instances = insts)

            elif cmd == 'status':

                (changd, result) = vgw.status()
                module.exit_json(changed = changd, status = result)

            elif cmd == "config" or cmd == "conf":

                (changd, cnf) = vgw.config()
                module.exit_json(changed = changd, config = cnf)

            elif cmd == 'ssh':
                # TODO: Fix This by using VBox API 

                (changd, cnf) = vgw.config()
                sshcmd = "ssh -i %s -p %s %s@%s" % (cnf["IdentityFile"], cnf["Port"], cnf["User"], cnf["HostName"])
                sshmsg = "Execute the command \"vagrant ssh %s\"" % (vm_name)
                module.exit_json(changed = changd, msg = sshmsg, SshCommand = sshcmd)

            elif cmd == 'halt':

                (changed, status) = vgw.halt()
                (ignore, status) = vgw.status()
                module.exit_json(changed = changed, status = status)

            elif cmd == 'destroy':

                changed = vgw.destroy()
                (ignore, status) = vgw.status()
                module.exit_json(changed = changed, status = status)

            else:

                module.fail_json(msg = "Unknown vagrant subcommand: \"%s\"." % (cmd))

    except subprocess.CalledProcessError as e:     
        module.fail_json(msg = "Vagrant command failed: %s." % (e))
    module.exit_json(status = "success")




# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>

main()
